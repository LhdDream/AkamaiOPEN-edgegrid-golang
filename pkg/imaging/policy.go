package imaging

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"net/http"
	"net/url"

	"github.com/akamai/AkamaiOPEN-edgegrid-golang/v2/pkg/edgegriderr"

	validation "github.com/go-ozzo/ozzo-validation/v4"
)

// Code in this package is using autogenerated code located in the policy.gen.go file.
// Generator code is located in `dxe-tools` repo, and it is using OpenApi schema from
// https://git.source.akamai.com/users/eleclair/repos/terraform/browse/docs/schemas

type (
	// Policies is an Image and Video Manager API interface for Policy
	//
	// See: https://techdocs.akamai.com/ivm/reference/api
	Policies interface {
		// ListPolicies lists all Policies for the given network and an account
		//
		// See: https://techdocs.akamai.com/ivm/reference/get-policies
		ListPolicies(context.Context, ListPoliciesRequest) (*ListPoliciesResponse, error)
	}

	// ListPoliciesRequest describes the parameters of the ListPolicies request
	ListPoliciesRequest struct {
		Network     PolicyNetwork
		Contract    string
		PolicySetID string
	}

	// ListPoliciesResponse is a response returned by CRU operations
	ListPoliciesResponse struct {
		ItemKind   string        `json:"itemKind"`
		Items      PolicyOutputs `json:"items"`
		TotalItems int           `json:"totalItems"`
	}

	// PolicyOutput is implemented by PolicyOutput types (image and video)
	PolicyOutput interface {
		policyOutputType() string
	}

	// PolicyOutputs is an array of PolicyOutput types (image and video)
	PolicyOutputs []PolicyOutput

	// PolicyNetwork represents the network where policy set is stored
	PolicyNetwork string
)

const (
	// PolicyNetworkStaging represents staging network
	PolicyNetworkStaging PolicyNetwork = "staging"
	// PolicyNetworkProduction represents production network
	PolicyNetworkProduction PolicyNetwork = "production"
)

var (
	// ErrUnmarshalPolicyOutputList represents an error while unmarshalling transformation list
	ErrUnmarshalPolicyOutputList = errors.New("unmarshalling policy output list")

	// ErrListPolicies is returned when ListPolicies fails
	ErrListPolicies = errors.New("list policies")
)

func (PolicyOutputImage) policyOutputType() string {
	return "Image"
}

func (PolicyOutputVideo) policyOutputType() string {
	return "Video"
}

var policyOutputHandlers = map[bool]func() PolicyOutput{
	false: func() PolicyOutput { return &PolicyOutputImage{} },
	true:  func() PolicyOutput { return &PolicyOutputVideo{} },
}

// UnmarshalJSON is a custom unmarshaler used to decode a slice of PolicyOutput interfaces
func (po *PolicyOutputs) UnmarshalJSON(in []byte) error {
	data := make([]map[string]interface{}, 0)
	if err := json.Unmarshal(in, &data); err != nil {
		return fmt.Errorf("%w: %s", ErrUnmarshalPolicyOutputList, err)
	}
	for _, policyOutput := range data {
		video, ok := policyOutput["video"]
		if !ok {
			return fmt.Errorf("%w: policyOutput should contain 'video' field", ErrUnmarshalPolicyOutputList)
		}
		isVideo, ok := video.(bool)
		if !ok {
			return fmt.Errorf("%w: 'video' field on policyOutput entry should be a boolean", ErrUnmarshalPolicyOutputList)
		}

		bytes, err := json.Marshal(policyOutput)
		if err != nil {
			return fmt.Errorf("%w: %s", ErrUnmarshalPolicyOutputList, err)
		}

		indicatedPolicyOutputType, ok := policyOutputHandlers[isVideo]
		if !ok {
			return fmt.Errorf("%w: unsupported policyOutput type: %v", ErrUnmarshalPolicyOutputList, isVideo)
		}
		ipt := indicatedPolicyOutputType()
		err = json.Unmarshal(bytes, ipt)
		if err != nil {
			return fmt.Errorf("%w: %s", ErrUnmarshalPolicyOutputList, err)
		}
		*po = append(*po, ipt)
	}
	return nil
}

// Validate validates ListPoliciesRequest
func (v ListPoliciesRequest) Validate() error {
	errs := validation.Errors{
		"Contract":    validation.Validate(v.Contract, validation.Required),
		"PolicySetID": validation.Validate(v.PolicySetID, validation.Required),
		"Network": validation.Validate(v.Network, validation.Required, validation.In(PolicyNetworkStaging, PolicyNetworkProduction).
			Error(fmt.Sprintf("network has to be '%s', '%s'", NetworkStaging, NetworkProduction))),
	}
	return edgegriderr.ParseValidationErrors(errs)
}

func (i *imaging) ListPolicies(ctx context.Context, params ListPoliciesRequest) (*ListPoliciesResponse, error) {
	logger := i.Log(ctx)
	logger.Debug("ListPolicies")

	if err := params.Validate(); err != nil {
		return nil, fmt.Errorf("%s: %w:\n%s", ErrListPolicies, ErrStructValidation, err)
	}

	uri, err := url.Parse(fmt.Sprintf("/imaging/v2/network/%s/policies/", params.Network))
	if err != nil {
		return nil, fmt.Errorf("%w: failed to parse url: %s", ErrListPolicies, err)
	}

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, uri.String(), nil)
	if err != nil {
		return nil, fmt.Errorf("%w: failed to create request: %s", ErrListPolicies, err)
	}

	req.Header.Set("Contract", params.Contract)
	req.Header.Set("Policy-Set", params.PolicySetID)

	var result ListPoliciesResponse
	resp, err := i.Exec(req, &result)
	if err != nil {
		return nil, fmt.Errorf("%w: request failed: %s", ErrListPolicies, err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("%s: %w", ErrListPolicies, i.Error(resp))
	}

	return &result, nil
}
